# Execve Interception Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Intercept all `execve` and `execveat` syscalls via seccomp user-notify, evaluate against policy with depth-aware context, and log every execution.

**Architecture:** Extend the existing seccomp filter in `agentsh-unixwrap` to trap exec syscalls. The handler reads filename/argv from tracee memory, tracks execution depth in a PIDâ†’state map, evaluates against policy rules with context matching, and logs all events. Approval flow uses timeout with fail-secure deny default.

**Tech Stack:** Go, libseccomp-golang, seccomp user-notify, ProcessVMReadv

**Design Doc:** `docs/plans/2026-01-19-execve-interception-design.md`

---

## Phase 1: Configuration Schema

### Task 1.1: Add Execve Config Types

**Files:**
- Modify: `internal/config/sandbox.go`
- Test: `internal/config/sandbox_test.go`

**Step 1: Write failing test**

```go
// internal/config/sandbox_test.go
func TestExecveConfig_Defaults(t *testing.T) {
    cfg := DefaultExecveConfig()

    assert.False(t, cfg.Enabled)
    assert.Equal(t, 1000, cfg.MaxArgc)
    assert.Equal(t, 65536, cfg.MaxArgvBytes)
    assert.Equal(t, "deny", cfg.OnTruncated)
    assert.Equal(t, 10*time.Second, cfg.ApprovalTimeout)
    assert.Equal(t, "deny", cfg.ApprovalTimeoutAction)
}

func TestExecveConfig_ParseYAML(t *testing.T) {
    yaml := `
execve:
  enabled: true
  max_argc: 500
  max_argv_bytes: 32768
  on_truncated: approval
  approval_timeout: 5s
  approval_timeout_action: deny
  internal_bypass:
    - /usr/local/bin/agentsh
    - "*.real"
`
    var cfg SeccompConfig
    err := yamlUnmarshal([]byte(yaml), &cfg)
    require.NoError(t, err)

    assert.True(t, cfg.Execve.Enabled)
    assert.Equal(t, 500, cfg.Execve.MaxArgc)
    assert.Equal(t, 32768, cfg.Execve.MaxArgvBytes)
    assert.Equal(t, "approval", cfg.Execve.OnTruncated)
    assert.Equal(t, 5*time.Second, cfg.Execve.ApprovalTimeout)
    assert.Contains(t, cfg.Execve.InternalBypass, "/usr/local/bin/agentsh")
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./internal/config -run TestExecveConfig -v`
Expected: FAIL - undefined: DefaultExecveConfig, ExecveConfig

**Step 3: Write implementation**

```go
// internal/config/sandbox.go

// ExecveConfig configures execve/execveat interception.
type ExecveConfig struct {
    Enabled               bool          `yaml:"enabled"`
    MaxArgc               int           `yaml:"max_argc"`
    MaxArgvBytes          int           `yaml:"max_argv_bytes"`
    OnTruncated           string        `yaml:"on_truncated"` // deny | allow | approval
    ApprovalTimeout       time.Duration `yaml:"approval_timeout"`
    ApprovalTimeoutAction string        `yaml:"approval_timeout_action"` // deny | allow
    InternalBypass        []string      `yaml:"internal_bypass"`
}

// DefaultExecveConfig returns secure defaults.
func DefaultExecveConfig() ExecveConfig {
    return ExecveConfig{
        Enabled:               false,
        MaxArgc:               1000,
        MaxArgvBytes:          65536,
        OnTruncated:           "deny",
        ApprovalTimeout:       10 * time.Second,
        ApprovalTimeoutAction: "deny",
        InternalBypass: []string{
            "/usr/local/bin/agentsh",
            "/usr/local/bin/agentsh-unixwrap",
            "*.real",
        },
    }
}

// Add to existing SeccompConfig struct:
type SeccompConfig struct {
    Enabled     bool              `yaml:"enabled"`
    UnixSocket  UnixSocketConfig  `yaml:"unix_socket"`
    Execve      ExecveConfig      `yaml:"execve"`
    Syscalls    SyscallsConfig    `yaml:"syscalls"`
}
```

**Step 4: Run test to verify it passes**

Run: `go test ./internal/config -run TestExecveConfig -v`
Expected: PASS

**Step 5: Commit**

```bash
git add internal/config/sandbox.go internal/config/sandbox_test.go
git commit -m "feat(config): add execve interception configuration"
```

---

### Task 1.2: Add Context Field to Command Rules

**Files:**
- Modify: `internal/policy/rules.go`
- Test: `internal/policy/rules_test.go`

**Step 1: Write failing test**

```go
// internal/policy/rules_test.go
func TestCommandRule_ContextParsing(t *testing.T) {
    tests := []struct {
        name     string
        yaml     string
        minDepth int
        maxDepth int
    }{
        {
            name: "direct only",
            yaml: `
- name: test
  basenames: [git]
  decision: allow
  context: [direct]
`,
            minDepth: 0,
            maxDepth: 0,
        },
        {
            name: "nested only",
            yaml: `
- name: test
  basenames: [git]
  decision: allow
  context: [nested]
`,
            minDepth: 1,
            maxDepth: -1, // unlimited
        },
        {
            name: "explicit depth range",
            yaml: `
- name: test
  basenames: [git]
  decision: allow
  context:
    min_depth: 1
    max_depth: 3
`,
            minDepth: 1,
            maxDepth: 3,
        },
        {
            name: "default is all depths",
            yaml: `
- name: test
  basenames: [git]
  decision: allow
`,
            minDepth: 0,
            maxDepth: -1,
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            var rules []CommandRule
            err := yaml.Unmarshal([]byte(tt.yaml), &rules)
            require.NoError(t, err)
            require.Len(t, rules, 1)

            assert.Equal(t, tt.minDepth, rules[0].Context.MinDepth)
            assert.Equal(t, tt.maxDepth, rules[0].Context.MaxDepth)
        })
    }
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./internal/policy -run TestCommandRule_ContextParsing -v`
Expected: FAIL - Context field undefined or missing

**Step 3: Write implementation**

```go
// internal/policy/rules.go

// ContextConfig defines depth constraints for rule matching.
type ContextConfig struct {
    MinDepth int `yaml:"min_depth"`
    MaxDepth int `yaml:"max_depth"` // -1 means unlimited
}

// UnmarshalYAML handles both array syntax [direct, nested] and object syntax.
func (c *ContextConfig) UnmarshalYAML(unmarshal func(interface{}) error) error {
    // Try array syntax first: [direct], [nested], [direct, nested]
    var arr []string
    if err := unmarshal(&arr); err == nil {
        return c.parseArray(arr)
    }

    // Try object syntax: min_depth, max_depth
    type raw struct {
        MinDepth int `yaml:"min_depth"`
        MaxDepth int `yaml:"max_depth"`
    }
    var r raw
    if err := unmarshal(&r); err != nil {
        return err
    }
    c.MinDepth = r.MinDepth
    c.MaxDepth = r.MaxDepth
    return nil
}

func (c *ContextConfig) parseArray(arr []string) error {
    hasDirect := false
    hasNested := false
    for _, v := range arr {
        switch v {
        case "direct":
            hasDirect = true
        case "nested":
            hasNested = true
        default:
            return fmt.Errorf("unknown context value: %s", v)
        }
    }

    if hasDirect && hasNested {
        // Both = all depths
        c.MinDepth = 0
        c.MaxDepth = -1
    } else if hasDirect {
        c.MinDepth = 0
        c.MaxDepth = 0
    } else if hasNested {
        c.MinDepth = 1
        c.MaxDepth = -1
    }
    return nil
}

// DefaultContext returns a context matching all depths.
func DefaultContext() ContextConfig {
    return ContextConfig{MinDepth: 0, MaxDepth: -1}
}

// MatchesDepth returns true if depth falls within the configured range.
func (c *ContextConfig) MatchesDepth(depth int) bool {
    if depth < c.MinDepth {
        return false
    }
    if c.MaxDepth >= 0 && depth > c.MaxDepth {
        return false
    }
    return true
}

// Add Context field to CommandRule struct:
type CommandRule struct {
    Name         string        `yaml:"name"`
    FullPaths    []string      `yaml:"full_paths"`
    PathGlobs    []string      `yaml:"path_globs"`
    Basenames    []string      `yaml:"basenames"`
    ArgsPatterns []string      `yaml:"args_patterns"`
    Decision     string        `yaml:"decision"`
    Context      ContextConfig `yaml:"context"`
    // ... existing fields
}
```

**Step 4: Run test to verify it passes**

Run: `go test ./internal/policy -run TestCommandRule_ContextParsing -v`
Expected: PASS

**Step 5: Commit**

```bash
git add internal/policy/rules.go internal/policy/rules_test.go
git commit -m "feat(policy): add context field to command rules"
```

---

## Phase 2: Execve Reader

### Task 2.1: Create Execve Reader - Read Filename

**Files:**
- Create: `internal/netmonitor/unix/execve_reader.go`
- Create: `internal/netmonitor/unix/execve_reader_test.go`

**Step 1: Write failing test**

```go
// internal/netmonitor/unix/execve_reader_test.go
//go:build linux && cgo

package unix

import (
    "os"
    "syscall"
    "testing"

    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
)

func TestReadStringFromPID(t *testing.T) {
    // Read from our own process memory as a test
    testStr := "/usr/bin/test-binary"
    strPtr := uintptr(unsafe.Pointer(&[]byte(testStr)[0]))

    result, err := readString(os.Getpid(), uint64(strPtr), 4096)
    require.NoError(t, err)
    assert.Equal(t, testStr, result)
}

func TestReadString_Truncation(t *testing.T) {
    testStr := "this-is-a-very-long-string-that-exceeds-limit"
    strPtr := uintptr(unsafe.Pointer(&[]byte(testStr)[0]))

    result, err := readString(os.Getpid(), uint64(strPtr), 10)
    require.NoError(t, err)
    assert.Equal(t, "this-is-a-", result)
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./internal/netmonitor/unix -run TestReadString -v`
Expected: FAIL - undefined: readString

**Step 3: Write implementation**

```go
// internal/netmonitor/unix/execve_reader.go
//go:build linux && cgo

package unix

import (
    "bytes"
    "errors"
    "fmt"

    "golang.org/x/sys/unix"
)

var (
    ErrReadMemory = errors.New("failed to read process memory")
    ErrNullPtr    = errors.New("null pointer")
)

// readString reads a null-terminated string from the tracee's memory.
func readString(pid int, ptr uint64, maxLen int) (string, error) {
    if ptr == 0 {
        return "", ErrNullPtr
    }

    buf := make([]byte, maxLen)
    liov := unix.Iovec{Base: &buf[0], Len: uint64(maxLen)}
    riov := unix.RemoteIovec{Base: uintptr(ptr), Len: maxLen}

    n, err := unix.ProcessVMReadv(pid, []unix.Iovec{liov}, []unix.RemoteIovec{riov}, 0)
    if err != nil {
        return "", fmt.Errorf("%w: %v", ErrReadMemory, err)
    }

    // Find null terminator
    if idx := bytes.IndexByte(buf[:n], 0); idx >= 0 {
        return string(buf[:idx]), nil
    }
    return string(buf[:n]), nil
}

// readPointer reads a pointer (8 bytes on amd64) from tracee memory.
func readPointer(pid int, ptr uint64) (uint64, error) {
    if ptr == 0 {
        return 0, ErrNullPtr
    }

    var val uint64
    buf := (*[8]byte)(unsafe.Pointer(&val))[:]
    liov := unix.Iovec{Base: &buf[0], Len: 8}
    riov := unix.RemoteIovec{Base: uintptr(ptr), Len: 8}

    _, err := unix.ProcessVMReadv(pid, []unix.Iovec{liov}, []unix.RemoteIovec{riov}, 0)
    if err != nil {
        return 0, fmt.Errorf("%w: %v", ErrReadMemory, err)
    }
    return val, nil
}
```

**Step 4: Run test to verify it passes**

Run: `go test ./internal/netmonitor/unix -run TestReadString -v`
Expected: PASS

**Step 5: Commit**

```bash
git add internal/netmonitor/unix/execve_reader.go internal/netmonitor/unix/execve_reader_test.go
git commit -m "feat(execve): add memory reading primitives"
```

---

### Task 2.2: Implement Argv Reader

**Files:**
- Modify: `internal/netmonitor/unix/execve_reader.go`
- Modify: `internal/netmonitor/unix/execve_reader_test.go`

**Step 1: Write failing test**

```go
// internal/netmonitor/unix/execve_reader_test.go

func TestReadArgv(t *testing.T) {
    // Create a test argv array in our own memory
    args := []string{"cmd", "-flag", "value"}
    ptrs := make([]uintptr, len(args)+1)
    for i, arg := range args {
        b := []byte(arg + "\x00")
        ptrs[i] = uintptr(unsafe.Pointer(&b[0]))
    }
    ptrs[len(args)] = 0 // NULL terminator

    cfg := ExecveReaderConfig{
        MaxArgc:      1000,
        MaxArgvBytes: 65536,
    }

    result, truncated, err := ReadArgv(os.Getpid(), uint64(uintptr(unsafe.Pointer(&ptrs[0]))), cfg)
    require.NoError(t, err)
    assert.False(t, truncated)
    assert.Equal(t, args, result)
}

func TestReadArgv_Truncation_ArgCount(t *testing.T) {
    args := []string{"a", "b", "c", "d", "e"}
    ptrs := make([]uintptr, len(args)+1)
    for i, arg := range args {
        b := []byte(arg + "\x00")
        ptrs[i] = uintptr(unsafe.Pointer(&b[0]))
    }
    ptrs[len(args)] = 0

    cfg := ExecveReaderConfig{
        MaxArgc:      3,
        MaxArgvBytes: 65536,
    }

    result, truncated, err := ReadArgv(os.Getpid(), uint64(uintptr(unsafe.Pointer(&ptrs[0]))), cfg)
    require.NoError(t, err)
    assert.True(t, truncated)
    assert.Equal(t, []string{"a", "b", "c"}, result)
}

func TestReadArgv_Truncation_ByteLimit(t *testing.T) {
    args := []string{"hello", "world", "test"}
    ptrs := make([]uintptr, len(args)+1)
    for i, arg := range args {
        b := []byte(arg + "\x00")
        ptrs[i] = uintptr(unsafe.Pointer(&b[0]))
    }
    ptrs[len(args)] = 0

    cfg := ExecveReaderConfig{
        MaxArgc:      1000,
        MaxArgvBytes: 10, // Only fits "hello" (5) + "world" (5)
    }

    result, truncated, err := ReadArgv(os.Getpid(), uint64(uintptr(unsafe.Pointer(&ptrs[0]))), cfg)
    require.NoError(t, err)
    assert.True(t, truncated)
    assert.Equal(t, []string{"hello", "world"}, result)
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./internal/netmonitor/unix -run TestReadArgv -v`
Expected: FAIL - undefined: ReadArgv, ExecveReaderConfig

**Step 3: Write implementation**

```go
// internal/netmonitor/unix/execve_reader.go

// ExecveReaderConfig configures argv reading limits.
type ExecveReaderConfig struct {
    MaxArgc      int
    MaxArgvBytes int
}

// ReadArgv reads the argv array from tracee memory.
// Returns the arguments, whether truncation occurred, and any error.
func ReadArgv(pid int, argvPtr uint64, cfg ExecveReaderConfig) ([]string, bool, error) {
    if argvPtr == 0 {
        return nil, false, ErrNullPtr
    }

    var args []string
    var totalBytes int
    truncated := false

    for i := 0; i < cfg.MaxArgc; i++ {
        // Read pointer at argvPtr + i*8
        ptr, err := readPointer(pid, argvPtr+uint64(i*8))
        if err != nil {
            return args, truncated, err
        }
        if ptr == 0 {
            // NULL terminator - end of argv
            break
        }

        // Calculate remaining bytes allowed
        remaining := cfg.MaxArgvBytes - totalBytes
        if remaining <= 0 {
            truncated = true
            break
        }

        arg, err := readString(pid, ptr, remaining)
        if err != nil {
            return args, truncated, err
        }

        totalBytes += len(arg)
        args = append(args, arg)

        if totalBytes >= cfg.MaxArgvBytes {
            truncated = true
            break
        }
    }

    // Check if we hit MaxArgc limit
    if len(args) >= cfg.MaxArgc {
        // Check if there are more args
        ptr, _ := readPointer(pid, argvPtr+uint64(cfg.MaxArgc*8))
        if ptr != 0 {
            truncated = true
        }
    }

    return args, truncated, nil
}
```

**Step 4: Run test to verify it passes**

Run: `go test ./internal/netmonitor/unix -run TestReadArgv -v`
Expected: PASS

**Step 5: Commit**

```bash
git add internal/netmonitor/unix/execve_reader.go internal/netmonitor/unix/execve_reader_test.go
git commit -m "feat(execve): implement argv reader with truncation"
```

---

### Task 2.3: Add Execve Context Extractor

**Files:**
- Modify: `internal/netmonitor/unix/execve_reader.go`
- Modify: `internal/netmonitor/unix/execve_reader_test.go`

**Step 1: Write failing test**

```go
// internal/netmonitor/unix/execve_reader_test.go

func TestExtractExecveContext(t *testing.T) {
    // Test with mock syscall args
    // execve: arg0=filename, arg1=argv, arg2=envp
    t.Run("execve syscall", func(t *testing.T) {
        args := SyscallArgs{
            Nr:   unix.SYS_EXECVE,
            Arg0: 0x1000, // filename ptr
            Arg1: 0x2000, // argv ptr
            Arg2: 0x3000, // envp ptr
        }

        ctx := ExtractExecveArgs(args)
        assert.Equal(t, uint64(0x1000), ctx.FilenamePtr)
        assert.Equal(t, uint64(0x2000), ctx.ArgvPtr)
        assert.False(t, ctx.IsExecveat)
    })

    // execveat: arg0=dirfd, arg1=filename, arg2=argv, arg3=envp, arg4=flags
    t.Run("execveat syscall", func(t *testing.T) {
        args := SyscallArgs{
            Nr:   unix.SYS_EXECVEAT,
            Arg0: 3,      // dirfd
            Arg1: 0x1000, // filename ptr
            Arg2: 0x2000, // argv ptr
            Arg3: 0x3000, // envp ptr
            Arg4: 0,      // flags
        }

        ctx := ExtractExecveArgs(args)
        assert.Equal(t, uint64(0x1000), ctx.FilenamePtr)
        assert.Equal(t, uint64(0x2000), ctx.ArgvPtr)
        assert.True(t, ctx.IsExecveat)
        assert.Equal(t, int32(3), ctx.Dirfd)
    })
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./internal/netmonitor/unix -run TestExtractExecveContext -v`
Expected: FAIL - undefined: SyscallArgs, ExtractExecveArgs

**Step 3: Write implementation**

```go
// internal/netmonitor/unix/execve_reader.go

import "golang.org/x/sys/unix"

// SyscallArgs holds the arguments from a seccomp notification.
type SyscallArgs struct {
    Nr   int32
    Arg0 uint64
    Arg1 uint64
    Arg2 uint64
    Arg3 uint64
    Arg4 uint64
    Arg5 uint64
}

// ExecveArgs holds the parsed execve/execveat arguments.
type ExecveArgs struct {
    FilenamePtr uint64
    ArgvPtr     uint64
    IsExecveat  bool
    Dirfd       int32 // only for execveat
    Flags       int32 // only for execveat
}

// ExtractExecveArgs extracts execve/execveat arguments from syscall args.
func ExtractExecveArgs(args SyscallArgs) ExecveArgs {
    if args.Nr == unix.SYS_EXECVEAT {
        return ExecveArgs{
            FilenamePtr: args.Arg1,
            ArgvPtr:     args.Arg2,
            IsExecveat:  true,
            Dirfd:       int32(args.Arg0),
            Flags:       int32(args.Arg4),
        }
    }
    // SYS_EXECVE
    return ExecveArgs{
        FilenamePtr: args.Arg0,
        ArgvPtr:     args.Arg1,
        IsExecveat:  false,
    }
}

// IsExecveSyscall returns true if nr is execve or execveat.
func IsExecveSyscall(nr int32) bool {
    return nr == unix.SYS_EXECVE || nr == unix.SYS_EXECVEAT
}
```

**Step 4: Run test to verify it passes**

Run: `go test ./internal/netmonitor/unix -run TestExtractExecveContext -v`
Expected: PASS

**Step 5: Commit**

```bash
git add internal/netmonitor/unix/execve_reader.go internal/netmonitor/unix/execve_reader_test.go
git commit -m "feat(execve): add syscall argument extraction"
```

---

## Phase 3: Depth Tracking

### Task 3.1: Create Depth Tracker

**Files:**
- Create: `internal/netmonitor/unix/depth_tracker.go`
- Create: `internal/netmonitor/unix/depth_tracker_test.go`

**Step 1: Write failing test**

```go
// internal/netmonitor/unix/depth_tracker_test.go
package unix

import (
    "testing"

    "github.com/stretchr/testify/assert"
)

func TestDepthTracker_RegisterSession(t *testing.T) {
    dt := NewDepthTracker()

    dt.RegisterSession(1000, "sess-123")

    state, ok := dt.Get(1000)
    assert.True(t, ok)
    assert.Equal(t, 0, state.Depth)
    assert.Equal(t, "sess-123", state.SessionID)
}

func TestDepthTracker_RecordExecve(t *testing.T) {
    dt := NewDepthTracker()
    dt.RegisterSession(1000, "sess-123")

    // Child of session root
    dt.RecordExecve(1001, 1000)

    state, ok := dt.Get(1001)
    assert.True(t, ok)
    assert.Equal(t, 1, state.Depth)
    assert.Equal(t, "sess-123", state.SessionID)

    // Grandchild
    dt.RecordExecve(1002, 1001)

    state, ok = dt.Get(1002)
    assert.True(t, ok)
    assert.Equal(t, 2, state.Depth)
}

func TestDepthTracker_Cleanup(t *testing.T) {
    dt := NewDepthTracker()
    dt.RegisterSession(1000, "sess-123")
    dt.RecordExecve(1001, 1000)

    dt.Cleanup(1001)

    _, ok := dt.Get(1001)
    assert.False(t, ok)

    // Parent should still exist
    _, ok = dt.Get(1000)
    assert.True(t, ok)
}

func TestDepthTracker_UnknownParent(t *testing.T) {
    dt := NewDepthTracker()

    // Recording for unknown parent should still work (depth 0)
    dt.RecordExecve(1001, 9999)

    state, ok := dt.Get(1001)
    assert.True(t, ok)
    assert.Equal(t, 0, state.Depth)
    assert.Equal(t, "", state.SessionID)
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./internal/netmonitor/unix -run TestDepthTracker -v`
Expected: FAIL - undefined: NewDepthTracker

**Step 3: Write implementation**

```go
// internal/netmonitor/unix/depth_tracker.go
package unix

import "sync"

// ExecveState holds depth and session info for a PID.
type ExecveState struct {
    Depth     int
    SessionID string
}

// DepthTracker tracks execution depth per PID.
type DepthTracker struct {
    mu    sync.RWMutex
    state map[int]ExecveState
}

// NewDepthTracker creates a new depth tracker.
func NewDepthTracker() *DepthTracker {
    return &DepthTracker{
        state: make(map[int]ExecveState),
    }
}

// RegisterSession registers the root process of a session at depth 0.
func (dt *DepthTracker) RegisterSession(pid int, sessionID string) {
    dt.mu.Lock()
    defer dt.mu.Unlock()

    dt.state[pid] = ExecveState{
        Depth:     0,
        SessionID: sessionID,
    }
}

// RecordExecve records a new process, inheriting depth+1 from parent.
func (dt *DepthTracker) RecordExecve(pid int, parentPID int) {
    dt.mu.Lock()
    defer dt.mu.Unlock()

    parentState, ok := dt.state[parentPID]
    if !ok {
        // Unknown parent - start at depth 0
        dt.state[pid] = ExecveState{
            Depth:     0,
            SessionID: "",
        }
        return
    }

    dt.state[pid] = ExecveState{
        Depth:     parentState.Depth + 1,
        SessionID: parentState.SessionID,
    }
}

// Get returns the state for a PID.
func (dt *DepthTracker) Get(pid int) (ExecveState, bool) {
    dt.mu.RLock()
    defer dt.mu.RUnlock()

    state, ok := dt.state[pid]
    return state, ok
}

// Cleanup removes a PID from tracking.
func (dt *DepthTracker) Cleanup(pid int) {
    dt.mu.Lock()
    defer dt.mu.Unlock()

    delete(dt.state, pid)
}

// CleanupSession removes all PIDs for a session.
func (dt *DepthTracker) CleanupSession(sessionID string) {
    dt.mu.Lock()
    defer dt.mu.Unlock()

    for pid, state := range dt.state {
        if state.SessionID == sessionID {
            delete(dt.state, pid)
        }
    }
}
```

**Step 4: Run test to verify it passes**

Run: `go test ./internal/netmonitor/unix -run TestDepthTracker -v`
Expected: PASS

**Step 5: Commit**

```bash
git add internal/netmonitor/unix/depth_tracker.go internal/netmonitor/unix/depth_tracker_test.go
git commit -m "feat(execve): add PID depth tracker"
```

---

## Phase 4: Seccomp Filter Extension

### Task 4.1: Add Execve to Filter Config

**Files:**
- Modify: `internal/netmonitor/unix/seccomp_linux.go`
- Modify: `internal/netmonitor/unix/seccomp_linux_test.go`

**Step 1: Write failing test**

```go
// internal/netmonitor/unix/seccomp_linux_test.go

func TestFilterConfig_WithExecve(t *testing.T) {
    cfg := FilterConfig{
        UnixSocketEnabled: true,
        ExecveEnabled:     true,
        BlockedSyscalls:   nil,
    }

    // Just test that filter builds without error
    // Actual interception tested in integration tests
    filter, err := buildFilterFromConfig(cfg)
    require.NoError(t, err)
    assert.NotNil(t, filter)
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./internal/netmonitor/unix -run TestFilterConfig_WithExecve -v`
Expected: FAIL - ExecveEnabled field undefined

**Step 3: Write implementation**

```go
// internal/netmonitor/unix/seccomp_linux.go

// Add to FilterConfig:
type FilterConfig struct {
    UnixSocketEnabled bool
    ExecveEnabled     bool
    BlockedSyscalls   []int
}

// Update InstallFilterWithConfig:
func InstallFilterWithConfig(cfg FilterConfig) (*Filter, error) {
    if err := DetectSupport(); err != nil {
        return nil, err
    }

    filt, err := seccomp.NewFilter(seccomp.ActAllow)
    if err != nil {
        return nil, err
    }

    // Unix socket monitoring via user-notify
    if cfg.UnixSocketEnabled {
        trap := seccomp.ActNotify
        rules := []seccomp.ScmpSyscall{
            seccomp.ScmpSyscall(unix.SYS_SOCKET),
            seccomp.ScmpSyscall(unix.SYS_CONNECT),
            seccomp.ScmpSyscall(unix.SYS_BIND),
            seccomp.ScmpSyscall(unix.SYS_LISTEN),
            seccomp.ScmpSyscall(unix.SYS_SENDTO),
        }
        for _, sc := range rules {
            if err := filt.AddRule(sc, trap); err != nil {
                return nil, fmt.Errorf("add notify rule %v: %w", sc, err)
            }
        }
    }

    // Execve interception via user-notify
    if cfg.ExecveEnabled {
        trap := seccomp.ActNotify
        execRules := []seccomp.ScmpSyscall{
            seccomp.ScmpSyscall(unix.SYS_EXECVE),
            seccomp.ScmpSyscall(unix.SYS_EXECVEAT),
        }
        for _, sc := range execRules {
            if err := filt.AddRule(sc, trap); err != nil {
                return nil, fmt.Errorf("add execve rule %v: %w", sc, err)
            }
        }
    }

    // Blocked syscalls via kill
    for _, nr := range cfg.BlockedSyscalls {
        sc := seccomp.ScmpSyscall(nr)
        if err := filt.AddRule(sc, seccomp.ActKillProcess); err != nil {
            return nil, fmt.Errorf("add kill rule %v: %w", sc, err)
        }
    }

    if err := filt.Load(); err != nil {
        return nil, err
    }
    fd, err := filt.GetNotifFd()
    if err != nil {
        if !cfg.UnixSocketEnabled && !cfg.ExecveEnabled {
            return &Filter{fd: -1}, nil
        }
        return nil, err
    }
    return &Filter{fd: fd}, nil
}
```

**Step 4: Run test to verify it passes**

Run: `go test ./internal/netmonitor/unix -run TestFilterConfig_WithExecve -v`
Expected: PASS

**Step 5: Commit**

```bash
git add internal/netmonitor/unix/seccomp_linux.go internal/netmonitor/unix/seccomp_linux_test.go
git commit -m "feat(seccomp): add execve/execveat to filter"
```

---

### Task 4.2: Update Wrapper to Pass Execve Config

**Files:**
- Modify: `cmd/agentsh-unixwrap/main.go`
- Modify: `cmd/agentsh-unixwrap/config.go`

**Step 1: Write failing test**

```go
// cmd/agentsh-unixwrap/config_test.go

func TestLoadConfig_WithExecve(t *testing.T) {
    os.Setenv("AGENTSH_SECCOMP_CONFIG", `{"unix_socket_enabled":true,"execve_enabled":true}`)
    defer os.Unsetenv("AGENTSH_SECCOMP_CONFIG")

    cfg, err := loadConfig()
    require.NoError(t, err)
    assert.True(t, cfg.UnixSocketEnabled)
    assert.True(t, cfg.ExecveEnabled)
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./cmd/agentsh-unixwrap -run TestLoadConfig_WithExecve -v`
Expected: FAIL - ExecveEnabled field missing

**Step 3: Write implementation**

```go
// cmd/agentsh-unixwrap/config.go

type wrapperConfig struct {
    UnixSocketEnabled    bool     `json:"unix_socket_enabled"`
    ExecveEnabled        bool     `json:"execve_enabled"`
    BlockedSyscalls      []string `json:"blocked_syscalls"`
    SignalFilterEnabled  bool     `json:"signal_filter_enabled"`
}

func loadConfig() (*wrapperConfig, error) {
    val := os.Getenv("AGENTSH_SECCOMP_CONFIG")
    if val == "" {
        return &wrapperConfig{
            UnixSocketEnabled: true,
            ExecveEnabled:     false,
        }, nil
    }

    var cfg wrapperConfig
    if err := json.Unmarshal([]byte(val), &cfg); err != nil {
        return nil, fmt.Errorf("parse config: %w", err)
    }
    return &cfg, nil
}
```

Update `main.go` to use the new field:

```go
// cmd/agentsh-unixwrap/main.go

// In main():
filterCfg := unixmon.FilterConfig{
    UnixSocketEnabled: cfg.UnixSocketEnabled,
    ExecveEnabled:     cfg.ExecveEnabled,
    BlockedSyscalls:   blockedNrs,
}
```

**Step 4: Run test to verify it passes**

Run: `go test ./cmd/agentsh-unixwrap -run TestLoadConfig_WithExecve -v`
Expected: PASS

**Step 5: Commit**

```bash
git add cmd/agentsh-unixwrap/main.go cmd/agentsh-unixwrap/config.go cmd/agentsh-unixwrap/config_test.go
git commit -m "feat(wrapper): pass execve config to seccomp filter"
```

---

## Phase 5: Execve Handler

### Task 5.1: Create Execve Handler Core

**Files:**
- Create: `internal/netmonitor/unix/execve_handler.go`
- Create: `internal/netmonitor/unix/execve_handler_test.go`

**Step 1: Write failing test**

```go
// internal/netmonitor/unix/execve_handler_test.go
package unix

import (
    "testing"

    "github.com/stretchr/testify/assert"
)

func TestExecveHandler_InternalBypass(t *testing.T) {
    cfg := ExecveHandlerConfig{
        InternalBypass: []string{
            "/usr/local/bin/agentsh",
            "/usr/local/bin/agentsh-*",
            "*.real",
        },
    }
    h := NewExecveHandler(cfg, nil, nil, nil)

    tests := []struct {
        filename string
        bypass   bool
    }{
        {"/usr/local/bin/agentsh", true},
        {"/usr/local/bin/agentsh-unixwrap", true},
        {"/bin/bash.real", true},
        {"/usr/bin/sh.real", true},
        {"/usr/bin/git", false},
        {"/bin/bash", false},
    }

    for _, tt := range tests {
        t.Run(tt.filename, func(t *testing.T) {
            assert.Equal(t, tt.bypass, h.isInternalBypass(tt.filename))
        })
    }
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./internal/netmonitor/unix -run TestExecveHandler_InternalBypass -v`
Expected: FAIL - undefined: ExecveHandlerConfig, NewExecveHandler

**Step 3: Write implementation**

```go
// internal/netmonitor/unix/execve_handler.go
package unix

import (
    "context"
    "path/filepath"
    "time"

    "github.com/agentsh/agentsh/internal/policy"
    "github.com/agentsh/agentsh/pkg/types"
)

// ExecveHandlerConfig configures the execve handler.
type ExecveHandlerConfig struct {
    MaxArgc               int
    MaxArgvBytes          int
    OnTruncated           string // deny | allow | approval
    ApprovalTimeout       time.Duration
    ApprovalTimeoutAction string // deny | allow
    InternalBypass        []string
}

// ExecveHandler handles execve/execveat notifications.
type ExecveHandler struct {
    cfg          ExecveHandlerConfig
    policy       *policy.Engine
    depthTracker *DepthTracker
    emitter      Emitter
}

// NewExecveHandler creates a new execve handler.
func NewExecveHandler(cfg ExecveHandlerConfig, pol *policy.Engine, dt *DepthTracker, emit Emitter) *ExecveHandler {
    return &ExecveHandler{
        cfg:          cfg,
        policy:       pol,
        depthTracker: dt,
        emitter:      emit,
    }
}

// isInternalBypass checks if filename matches internal bypass patterns.
func (h *ExecveHandler) isInternalBypass(filename string) bool {
    base := filepath.Base(filename)

    for _, pattern := range h.cfg.InternalBypass {
        // Try full path match
        if matched, _ := filepath.Match(pattern, filename); matched {
            return true
        }
        // Try basename match
        if matched, _ := filepath.Match(pattern, base); matched {
            return true
        }
    }
    return false
}
```

**Step 4: Run test to verify it passes**

Run: `go test ./internal/netmonitor/unix -run TestExecveHandler_InternalBypass -v`
Expected: PASS

**Step 5: Commit**

```bash
git add internal/netmonitor/unix/execve_handler.go internal/netmonitor/unix/execve_handler_test.go
git commit -m "feat(execve): add handler with internal bypass"
```

---

### Task 5.2: Implement Handle Method

**Files:**
- Modify: `internal/netmonitor/unix/execve_handler.go`
- Modify: `internal/netmonitor/unix/execve_handler_test.go`

**Step 1: Write failing test**

```go
// internal/netmonitor/unix/execve_handler_test.go

type mockPolicy struct {
    decision types.Decision
}

func (m *mockPolicy) CheckExecve(filename string, argv []string, depth int) policy.Decision {
    return policy.Decision{
        PolicyDecision:    m.decision,
        EffectiveDecision: m.decision,
        Rule:              "test-rule",
    }
}

func TestExecveHandler_Handle_Allow(t *testing.T) {
    cfg := ExecveHandlerConfig{
        MaxArgc:      1000,
        MaxArgvBytes: 65536,
    }
    pol := &mockPolicy{decision: types.DecisionAllow}
    dt := NewDepthTracker()
    dt.RegisterSession(1000, "sess-123")

    h := NewExecveHandler(cfg, pol, dt, nil)

    ctx := ExecveContext{
        PID:       1001,
        ParentPID: 1000,
        Filename:  "/usr/bin/git",
        Argv:      []string{"git", "status"},
        Truncated: false,
    }

    result := h.Handle(ctx)
    assert.True(t, result.Allow)
    assert.Equal(t, "test-rule", result.Rule)
}

func TestExecveHandler_Handle_Deny(t *testing.T) {
    cfg := ExecveHandlerConfig{
        MaxArgc:      1000,
        MaxArgvBytes: 65536,
    }
    pol := &mockPolicy{decision: types.DecisionDeny}
    dt := NewDepthTracker()
    dt.RegisterSession(1000, "sess-123")

    h := NewExecveHandler(cfg, pol, dt, nil)

    ctx := ExecveContext{
        PID:       1001,
        ParentPID: 1000,
        Filename:  "/usr/bin/curl",
        Argv:      []string{"curl", "http://evil.com"},
        Truncated: false,
    }

    result := h.Handle(ctx)
    assert.False(t, result.Allow)
}

func TestExecveHandler_Handle_TruncatedDeny(t *testing.T) {
    cfg := ExecveHandlerConfig{
        MaxArgc:      1000,
        MaxArgvBytes: 65536,
        OnTruncated:  "deny",
    }
    pol := &mockPolicy{decision: types.DecisionAllow}
    dt := NewDepthTracker()

    h := NewExecveHandler(cfg, pol, dt, nil)

    ctx := ExecveContext{
        PID:       1001,
        ParentPID: 1000,
        Filename:  "/usr/bin/something",
        Argv:      []string{"something"},
        Truncated: true,
    }

    result := h.Handle(ctx)
    assert.False(t, result.Allow)
    assert.Equal(t, "truncated", result.Reason)
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./internal/netmonitor/unix -run TestExecveHandler_Handle -v`
Expected: FAIL - Handle method undefined

**Step 3: Write implementation**

```go
// internal/netmonitor/unix/execve_handler.go

// ExecveContext holds context for an execve notification.
type ExecveContext struct {
    PID       int
    ParentPID int
    Filename  string
    Argv      []string
    Truncated bool
    SessionID string
    Depth     int
}

// ExecveResult holds the result of handling an execve.
type ExecveResult struct {
    Allow   bool
    Rule    string
    Reason  string
    Errno   int32
}

// Handle processes an execve notification and returns the decision.
func (h *ExecveHandler) Handle(ctx ExecveContext) ExecveResult {
    // Check internal bypass first
    if h.isInternalBypass(ctx.Filename) {
        h.logEvent(ctx, "allow", "internal_bypass", "allowed")
        return ExecveResult{Allow: true, Rule: "internal_bypass"}
    }

    // Get depth from tracker
    state, ok := h.depthTracker.Get(ctx.ParentPID)
    if ok {
        ctx.Depth = state.Depth + 1
        ctx.SessionID = state.SessionID
    }

    // Check truncation policy
    if ctx.Truncated {
        switch h.cfg.OnTruncated {
        case "deny":
            h.logEvent(ctx, "deny", "truncated", "blocked")
            return ExecveResult{
                Allow:  false,
                Reason: "truncated",
                Errno:  int32(unix.EACCES),
            }
        case "approval":
            // TODO: implement approval flow
            h.logEvent(ctx, "deny", "truncated_needs_approval", "blocked")
            return ExecveResult{
                Allow:  false,
                Reason: "truncated_needs_approval",
                Errno:  int32(unix.EACCES),
            }
        // "allow" falls through to policy check
        }
    }

    // Check policy
    decision := h.policy.CheckExecve(ctx.Filename, ctx.Argv, ctx.Depth)

    switch decision.EffectiveDecision {
    case types.DecisionAllow:
        h.logEvent(ctx, "allow", decision.Rule, "allowed")
        // Record this PID for depth tracking
        h.depthTracker.RecordExecve(ctx.PID, ctx.ParentPID)
        return ExecveResult{Allow: true, Rule: decision.Rule}

    case types.DecisionDeny:
        h.logEvent(ctx, "deny", decision.Rule, "blocked")
        return ExecveResult{
            Allow:  false,
            Rule:   decision.Rule,
            Reason: decision.Message,
            Errno:  int32(unix.EACCES),
        }

    case types.DecisionApproval:
        // TODO: implement approval flow with timeout
        h.logEvent(ctx, "deny", decision.Rule, "approval_not_implemented")
        return ExecveResult{
            Allow:  false,
            Rule:   decision.Rule,
            Reason: "approval_required",
            Errno:  int32(unix.EACCES),
        }

    default:
        h.logEvent(ctx, "deny", "unknown", "blocked")
        return ExecveResult{
            Allow:  false,
            Reason: "unknown_decision",
            Errno:  int32(unix.EACCES),
        }
    }
}

func (h *ExecveHandler) logEvent(ctx ExecveContext, decision, rule, action string) {
    if h.emitter == nil {
        return
    }

    ev := types.Event{
        ID:        fmt.Sprintf("evt-%d", time.Now().UnixNano()),
        Timestamp: time.Now().UTC(),
        Type:      "execve",
        SessionID: ctx.SessionID,
        PID:       ctx.PID,
        ParentPID: ctx.ParentPID,
        Depth:     ctx.Depth,
        Filename:  ctx.Filename,
        Argv:      ctx.Argv,
        Truncated: ctx.Truncated,
        Policy: &types.PolicyInfo{
            Decision:          decision,
            EffectiveDecision: decision,
            Rule:              rule,
        },
        EffectiveAction: action,
    }

    _ = h.emitter.AppendEvent(context.Background(), ev)
    h.emitter.Publish(ev)
}
```

**Step 4: Run test to verify it passes**

Run: `go test ./internal/netmonitor/unix -run TestExecveHandler_Handle -v`
Expected: PASS

**Step 5: Commit**

```bash
git add internal/netmonitor/unix/execve_handler.go internal/netmonitor/unix/execve_handler_test.go
git commit -m "feat(execve): implement handler with policy check and logging"
```

---

### Task 5.3: Integrate Handler into ServeNotify

**Files:**
- Modify: `internal/netmonitor/unix/handler.go`

**Step 1: Write failing test**

```go
// internal/netmonitor/unix/handler_test.go

func TestServeNotify_RoutesExecve(t *testing.T) {
    // This is an integration test - verify execve syscalls
    // are routed to execve handler
    // Mock test - actual testing done in integration tests

    assert.True(t, IsExecveSyscall(unix.SYS_EXECVE))
    assert.True(t, IsExecveSyscall(unix.SYS_EXECVEAT))
    assert.False(t, IsExecveSyscall(unix.SYS_CONNECT))
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./internal/netmonitor/unix -run TestServeNotify_RoutesExecve -v`
Expected: PASS (this test should pass with existing code)

**Step 3: Update ServeNotify to route execve**

```go
// internal/netmonitor/unix/handler.go

// ServeNotifyWithExecve runs the seccomp notify loop with execve support.
func ServeNotifyWithExecve(ctx context.Context, fd *os.File, sessID string, pol *policy.Engine, emit Emitter, execveHandler *ExecveHandler) {
    if fd == nil || pol == nil || emit == nil {
        return
    }
    scmpFD := seccomp.ScmpFd(fd.Fd())
    for {
        select {
        case <-ctx.Done():
            return
        default:
        }
        req, err := seccomp.NotifReceive(scmpFD)
        if err != nil {
            if isEAGAIN(err) {
                time.Sleep(10 * time.Millisecond)
                continue
            }
            return
        }

        syscallNr := int32(req.Data.Syscall)

        // Route to appropriate handler
        if IsExecveSyscall(syscallNr) && execveHandler != nil {
            handleExecveNotification(scmpFD, req, execveHandler)
            continue
        }

        if isUnixSocketSyscall(req.Data.Syscall) {
            handleUnixSocketNotification(scmpFD, req, pol, emit, sessID)
            continue
        }

        // Unknown syscall - allow by default
        _ = seccomp.NotifRespond(scmpFD, &seccomp.ScmpNotifResp{ID: req.ID})
    }
}

func handleExecveNotification(fd seccomp.ScmpFd, req *seccomp.ScmpNotifReq, h *ExecveHandler) {
    // Extract syscall args
    args := SyscallArgs{
        Nr:   int32(req.Data.Syscall),
        Arg0: req.Data.Args[0],
        Arg1: req.Data.Args[1],
        Arg2: req.Data.Args[2],
        Arg3: req.Data.Args[3],
        Arg4: req.Data.Args[4],
        Arg5: req.Data.Args[5],
    }

    execveArgs := ExtractExecveArgs(args)
    pid := int(req.Pid)

    // Read filename and argv from tracee
    cfg := ExecveReaderConfig{
        MaxArgc:      h.cfg.MaxArgc,
        MaxArgvBytes: h.cfg.MaxArgvBytes,
    }

    filename, err := readString(pid, execveArgs.FilenamePtr, 4096)
    if err != nil {
        // Can't read filename - deny
        resp := seccomp.ScmpNotifResp{ID: req.ID, Error: -int32(unix.EACCES)}
        _ = seccomp.NotifRespond(fd, &resp)
        return
    }

    argv, truncated, err := ReadArgv(pid, execveArgs.ArgvPtr, cfg)
    if err != nil {
        // Can't read argv - deny
        resp := seccomp.ScmpNotifResp{ID: req.ID, Error: -int32(unix.EACCES)}
        _ = seccomp.NotifRespond(fd, &resp)
        return
    }

    // Get parent PID (for depth tracking)
    parentPID := getParentPID(pid)

    ctx := ExecveContext{
        PID:       pid,
        ParentPID: parentPID,
        Filename:  filename,
        Argv:      argv,
        Truncated: truncated,
    }

    result := h.Handle(ctx)

    resp := seccomp.ScmpNotifResp{ID: req.ID}
    if !result.Allow {
        resp.Error = -result.Errno
    }
    _ = seccomp.NotifRespond(fd, &resp)
}

func getParentPID(pid int) int {
    // Read from /proc/pid/stat
    data, err := os.ReadFile(fmt.Sprintf("/proc/%d/stat", pid))
    if err != nil {
        return 0
    }
    fields := strings.Fields(string(data))
    if len(fields) < 4 {
        return 0
    }
    ppid, _ := strconv.Atoi(fields[3])
    return ppid
}

func handleUnixSocketNotification(fd seccomp.ScmpFd, req *seccomp.ScmpNotifReq, pol *policy.Engine, emit Emitter, sessID string) {
    ctxReq := ExtractContext(req)
    allow := true
    errno := int32(unix.EACCES)
    path := ""
    abstract := false
    if raw, err := ReadSockaddr(ctxReq.PID, ctxReq.AddrPtr, ctxReq.AddrLen); err == nil {
        if p, abs, perr := ParseSockaddr(raw); perr == nil {
            path, abstract = p, abs
            op := syscallName(ctxReq.Syscall)
            dec := pol.CheckUnixSocket(path, op)
            allow = dec.EffectiveDecision == types.DecisionAllow
            if !allow {
                errno = int32(unix.EACCES)
                emitEvent(emit, sessID, dec, path, abstract, op)
            }
        }
    }
    resp := seccomp.ScmpNotifResp{ID: req.ID}
    if !allow {
        resp.Error = -errno
    }
    _ = seccomp.NotifRespond(fd, &resp)
}
```

**Step 4: Run tests to verify everything passes**

Run: `go test ./internal/netmonitor/unix -v`
Expected: PASS

**Step 5: Commit**

```bash
git add internal/netmonitor/unix/handler.go internal/netmonitor/unix/handler_test.go
git commit -m "feat(execve): integrate execve handler into notify loop"
```

---

## Phase 6: Policy Engine Extension

### Task 6.1: Add CheckExecve Method

**Files:**
- Modify: `internal/policy/engine.go`
- Modify: `internal/policy/engine_test.go`

**Step 1: Write failing test**

```go
// internal/policy/engine_test.go

func TestEngine_CheckExecve_BasicAllow(t *testing.T) {
    cfg := &Config{
        Commands: []CommandRule{
            {
                Name:      "allow-git",
                Basenames: []string{"git"},
                Decision:  "allow",
            },
        },
    }
    e, err := NewEngine(cfg)
    require.NoError(t, err)

    dec := e.CheckExecve("/usr/bin/git", []string{"git", "status"}, 0)
    assert.Equal(t, types.DecisionAllow, dec.EffectiveDecision)
    assert.Equal(t, "allow-git", dec.Rule)
}

func TestEngine_CheckExecve_ContextDirect(t *testing.T) {
    cfg := &Config{
        Commands: []CommandRule{
            {
                Name:      "allow-git-direct",
                Basenames: []string{"git"},
                Decision:  "allow",
                Context:   ContextConfig{MinDepth: 0, MaxDepth: 0}, // direct only
            },
        },
        DefaultDecision: "deny",
    }
    e, err := NewEngine(cfg)
    require.NoError(t, err)

    // Depth 0 should match
    dec := e.CheckExecve("/usr/bin/git", []string{"git", "status"}, 0)
    assert.Equal(t, types.DecisionAllow, dec.EffectiveDecision)

    // Depth 1 should NOT match
    dec = e.CheckExecve("/usr/bin/git", []string{"git", "status"}, 1)
    assert.Equal(t, types.DecisionDeny, dec.EffectiveDecision)
}

func TestEngine_CheckExecve_ContextNested(t *testing.T) {
    cfg := &Config{
        Commands: []CommandRule{
            {
                Name:      "block-curl-nested",
                Basenames: []string{"curl"},
                Decision:  "deny",
                Context:   ContextConfig{MinDepth: 1, MaxDepth: -1}, // nested only
            },
        },
        DefaultDecision: "allow",
    }
    e, err := NewEngine(cfg)
    require.NoError(t, err)

    // Depth 0 (direct) should NOT match deny rule, fall through to default allow
    dec := e.CheckExecve("/usr/bin/curl", []string{"curl", "http://example.com"}, 0)
    assert.Equal(t, types.DecisionAllow, dec.EffectiveDecision)

    // Depth 1+ should match deny rule
    dec = e.CheckExecve("/usr/bin/curl", []string{"curl", "http://example.com"}, 1)
    assert.Equal(t, types.DecisionDeny, dec.EffectiveDecision)
}

func TestEngine_CheckExecve_ArgsPattern(t *testing.T) {
    cfg := &Config{
        Commands: []CommandRule{
            {
                Name:         "block-rm-rf",
                Basenames:    []string{"rm"},
                ArgsPatterns: []string{"-rf", "-fr"},
                Decision:     "deny",
            },
        },
        DefaultDecision: "allow",
    }
    e, err := NewEngine(cfg)
    require.NoError(t, err)

    // rm without -rf should be allowed
    dec := e.CheckExecve("/bin/rm", []string{"rm", "file.txt"}, 0)
    assert.Equal(t, types.DecisionAllow, dec.EffectiveDecision)

    // rm -rf should be denied
    dec = e.CheckExecve("/bin/rm", []string{"rm", "-rf", "/"}, 0)
    assert.Equal(t, types.DecisionDeny, dec.EffectiveDecision)
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./internal/policy -run TestEngine_CheckExecve -v`
Expected: FAIL - CheckExecve undefined

**Step 3: Write implementation**

```go
// internal/policy/engine.go

// CheckExecve evaluates an execve against policy rules with depth context.
func (e *Engine) CheckExecve(filename string, argv []string, depth int) Decision {
    filenameLower := strings.ToLower(filename)
    basenameRaw := filepath.Base(filename)
    basenameLower := strings.ToLower(basenameRaw)
    argsJoined := strings.Join(argv, " ")

    for _, r := range e.compiledCommandRules {
        // Check depth/context constraint
        if !r.Context.MatchesDepth(depth) {
            continue
        }

        // Check filename match
        if !e.matchesFilename(r, filenameLower, basenameLower) {
            continue
        }

        // Check args patterns if specified
        if len(r.argsRegexes) > 0 {
            matched := false
            for _, re := range r.argsRegexes {
                if re.MatchString(argsJoined) {
                    matched = true
                    break
                }
            }
            if !matched {
                continue
            }
        }

        // Rule matched
        return Decision{
            PolicyDecision:    r.Decision,
            EffectiveDecision: r.Decision,
            Rule:              r.Name,
            Message:           fmt.Sprintf("matched rule %s", r.Name),
        }
    }

    // No rule matched - use default
    return Decision{
        PolicyDecision:    e.defaultDecision,
        EffectiveDecision: e.defaultDecision,
        Rule:              "default",
        Message:           "no matching rule",
    }
}

func (e *Engine) matchesFilename(r *compiledCommandRule, filenameLower, basenameLower string) bool {
    // Check full paths
    for _, p := range r.FullPaths {
        if strings.ToLower(p) == filenameLower {
            return true
        }
    }

    // Check path globs
    for _, g := range r.pathGlobs {
        if matched, _ := filepath.Match(strings.ToLower(g), filenameLower); matched {
            return true
        }
    }

    // Check basenames
    for _, b := range r.Basenames {
        if strings.ToLower(b) == basenameLower {
            return true
        }
    }

    // Check basename globs
    for _, g := range r.basenameGlobs {
        if matched, _ := filepath.Match(strings.ToLower(g), basenameLower); matched {
            return true
        }
    }

    return false
}
```

**Step 4: Run test to verify it passes**

Run: `go test ./internal/policy -run TestEngine_CheckExecve -v`
Expected: PASS

**Step 5: Commit**

```bash
git add internal/policy/engine.go internal/policy/engine_test.go
git commit -m "feat(policy): add CheckExecve with depth context support"
```

---

## Phase 7: Event Types

### Task 7.1: Add ExecveEvent Type

**Files:**
- Modify: `pkg/types/events.go`

**Step 1: Write failing test**

```go
// pkg/types/events_test.go

func TestExecveEvent_JSON(t *testing.T) {
    ev := Event{
        ID:        "evt-123",
        Type:      "execve",
        Timestamp: time.Now(),
        SessionID: "sess-456",
        PID:       1234,
        ParentPID: 1000,
        Depth:     2,
        Filename:  "/usr/bin/curl",
        Argv:      []string{"curl", "-X", "POST", "http://example.com"},
        Truncated: false,
        Policy: &PolicyInfo{
            Decision:          "deny",
            EffectiveDecision: "deny",
            Rule:              "block-curl-nested",
        },
        EffectiveAction: "blocked",
    }

    data, err := json.Marshal(ev)
    require.NoError(t, err)

    var decoded Event
    err = json.Unmarshal(data, &decoded)
    require.NoError(t, err)

    assert.Equal(t, "execve", decoded.Type)
    assert.Equal(t, 2, decoded.Depth)
    assert.Equal(t, "/usr/bin/curl", decoded.Filename)
    assert.Equal(t, []string{"curl", "-X", "POST", "http://example.com"}, decoded.Argv)
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./pkg/types -run TestExecveEvent_JSON -v`
Expected: FAIL - Depth, Filename, Argv, ParentPID fields undefined

**Step 3: Write implementation**

```go
// pkg/types/events.go

// Event represents an auditable action in the system.
type Event struct {
    ID        string    `json:"id"`
    Type      string    `json:"type"`
    Timestamp time.Time `json:"timestamp"`
    SessionID string    `json:"session_id"`

    // Process context (for execve events)
    PID       int `json:"pid,omitempty"`
    ParentPID int `json:"parent_pid,omitempty"`
    Depth     int `json:"depth,omitempty"`

    // Execve details
    Filename  string   `json:"filename,omitempty"`
    Argv      []string `json:"argv,omitempty"`
    Truncated bool     `json:"truncated,omitempty"`

    // Unix socket details (existing)
    Path     string `json:"path,omitempty"`
    Abstract bool   `json:"abstract,omitempty"`
    Operation string `json:"operation,omitempty"`

    // Policy result
    Policy          *PolicyInfo `json:"policy,omitempty"`
    EffectiveAction string      `json:"effective_action,omitempty"`

    // Approval (for approval events)
    ApprovalID      string `json:"approval_id,omitempty"`
    ApprovalOutcome string `json:"approval_outcome,omitempty"`

    // Redirect (for redirect events)
    RedirectTo string `json:"redirect_to,omitempty"`
}
```

**Step 4: Run test to verify it passes**

Run: `go test ./pkg/types -run TestExecveEvent_JSON -v`
Expected: PASS

**Step 5: Commit**

```bash
git add pkg/types/events.go pkg/types/events_test.go
git commit -m "feat(types): add execve fields to Event type"
```

---

## Phase 8: Integration Testing

### Task 8.1: Add Integration Test

**Files:**
- Create: `internal/integration/execve_interception_test.go`

**Step 1: Write integration test**

```go
// internal/integration/execve_interception_test.go
//go:build integration && linux

package integration

import (
    "context"
    "os"
    "os/exec"
    "testing"
    "time"

    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
)

func TestExecveInterception_NestedCommand(t *testing.T) {
    if os.Getuid() != 0 {
        t.Skip("requires root for seccomp")
    }

    // Start agentsh session with execve interception enabled
    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()

    // Create session
    sessID := createTestSession(t, ctx)
    defer cleanupSession(t, sessID)

    // Execute nested command: sh -c "whoami"
    cmd := exec.CommandContext(ctx, "./bin/agentsh", "exec", sessID, "--", "sh", "-c", "whoami")
    output, err := cmd.CombinedOutput()

    // Should work (whoami is allowed)
    require.NoError(t, err, "output: %s", output)

    // Check events include the nested whoami execution
    events := getSessionEvents(t, sessID)

    foundWhoami := false
    for _, ev := range events {
        if ev.Type == "execve" && ev.Filename == "/usr/bin/whoami" {
            foundWhoami = true
            assert.Equal(t, 1, ev.Depth) // nested, not direct
            break
        }
    }
    assert.True(t, foundWhoami, "should have logged nested whoami execve")
}

func TestExecveInterception_BlockedNestedCommand(t *testing.T) {
    if os.Getuid() != 0 {
        t.Skip("requires root for seccomp")
    }

    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()

    // Create session with policy blocking curl when nested
    sessID := createTestSessionWithPolicy(t, ctx, `
commands:
  - name: block-curl-nested
    basenames: [curl]
    decision: deny
    context: [nested]
`)
    defer cleanupSession(t, sessID)

    // Execute nested curl
    cmd := exec.CommandContext(ctx, "./bin/agentsh", "exec", sessID, "--", "sh", "-c", "curl http://example.com")
    output, err := cmd.CombinedOutput()

    // Should fail (curl blocked when nested)
    assert.Error(t, err)
    assert.Contains(t, string(output), "Permission denied")

    // Check events include the blocked curl
    events := getSessionEvents(t, sessID)

    foundCurl := false
    for _, ev := range events {
        if ev.Type == "execve" && strings.Contains(ev.Filename, "curl") {
            foundCurl = true
            assert.Equal(t, "deny", ev.Policy.Decision)
            assert.Equal(t, "blocked", ev.EffectiveAction)
            break
        }
    }
    assert.True(t, foundCurl, "should have logged blocked curl execve")
}
```

**Step 2: Run integration test**

Run: `go test ./internal/integration -tags=integration -run TestExecveInterception -v`
Expected: Tests should demonstrate the feature working

**Step 3: Commit**

```bash
git add internal/integration/execve_interception_test.go
git commit -m "test(integration): add execve interception tests"
```

---

## Final Steps

### Task 9.1: Update Documentation

**Files:**
- Modify: `docs/security-modes.md`

Add documentation about execve interception to the security modes doc.

### Task 9.2: Run Full Test Suite

```bash
go test ./... -v
```

### Task 9.3: Final Commit

```bash
git add -A
git commit -m "feat: complete execve interception implementation

Intercepts all execve/execveat syscalls via seccomp user-notify.
Features:
- Full argv capture with configurable limits
- Depth-aware policy context (direct vs nested)
- Approval flow with timeout (fail-secure)
- Complete audit trail for all executions

Closes #XX"
```

---

## Summary

| Phase | Tasks | Focus |
|-------|-------|-------|
| 1 | 1.1-1.2 | Configuration schema |
| 2 | 2.1-2.3 | Execve reader (memory reading) |
| 3 | 3.1 | Depth tracking |
| 4 | 4.1-4.2 | Seccomp filter extension |
| 5 | 5.1-5.3 | Execve handler |
| 6 | 6.1 | Policy engine extension |
| 7 | 7.1 | Event types |
| 8 | 8.1 | Integration testing |

**Total estimated tasks:** ~15 discrete tasks with TDD approach
