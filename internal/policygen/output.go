// internal/policygen/output.go
package policygen

import (
	"fmt"
	"strings"
	"time"
)

// FormatYAML formats a generated policy as YAML with provenance comments.
func FormatYAML(policy *GeneratedPolicy, name string) string {
	var b strings.Builder

	// Header comments
	b.WriteString(fmt.Sprintf("# Generated by: agentsh policy generate %s\n", policy.SessionID))
	b.WriteString(fmt.Sprintf("# Source session: %s\n", policy.SessionID))
	b.WriteString(fmt.Sprintf("# Generated at: %s\n", policy.GeneratedAt.Format("2006-01-02T15:04:05Z")))
	b.WriteString(fmt.Sprintf("# Session duration: %s\n", formatDuration(policy.Duration)))
	b.WriteString(fmt.Sprintf("# Total events analyzed: %d\n", policy.EventCount))
	b.WriteString("\n")

	// Policy metadata
	b.WriteString("version: 1\n")
	if name != "" {
		b.WriteString(fmt.Sprintf("name: %s\n", name))
	} else {
		b.WriteString(fmt.Sprintf("name: generated-%s\n", truncateID(policy.SessionID)))
	}
	b.WriteString(fmt.Sprintf("description: Auto-generated from session %s\n", policy.SessionID))
	b.WriteString("\n")

	// File rules section
	if len(policy.FileRules) > 0 || len(policy.BlockedFiles) > 0 {
		b.WriteString("file_rules:\n")
		for _, rule := range policy.FileRules {
			writeFileRule(&b, rule, false)
		}
		if len(policy.BlockedFiles) > 0 {
			b.WriteString("  # --- Blocked operations (uncomment to allow) ---\n")
			for _, rule := range policy.BlockedFiles {
				writeFileRule(&b, rule, true)
			}
		}
		b.WriteString("\n")
	}

	// Network rules section
	if len(policy.NetworkRules) > 0 || len(policy.BlockedNetwork) > 0 {
		b.WriteString("network_rules:\n")
		for _, rule := range policy.NetworkRules {
			writeNetworkRule(&b, rule, false)
		}
		if len(policy.BlockedNetwork) > 0 {
			b.WriteString("  # --- Blocked operations (uncomment to allow) ---\n")
			for _, rule := range policy.BlockedNetwork {
				writeNetworkRule(&b, rule, true)
			}
		}
		b.WriteString("\n")
	}

	// Command rules section
	if len(policy.CommandRules) > 0 || len(policy.BlockedCommands) > 0 {
		b.WriteString("command_rules:\n")
		for _, rule := range policy.CommandRules {
			writeCommandRule(&b, rule, false)
		}
		if len(policy.BlockedCommands) > 0 {
			b.WriteString("  # --- Blocked operations (uncomment to allow) ---\n")
			for _, rule := range policy.BlockedCommands {
				writeCommandRule(&b, rule, true)
			}
		}
		b.WriteString("\n")
	}

	// Unix socket rules section
	if len(policy.UnixRules) > 0 {
		b.WriteString("unix_socket_rules:\n")
		for _, rule := range policy.UnixRules {
			writeUnixRule(&b, rule)
		}
		b.WriteString("\n")
	}

	// MCP rules section
	if len(policy.MCPToolRules) > 0 || len(policy.MCPBlockedTools) > 0 || policy.MCPConfig != nil {
		b.WriteString("mcp_rules:\n")
		b.WriteString("  enforce_policy: true\n")

		// Tool allowlist
		if len(policy.MCPToolRules) > 0 {
			b.WriteString("  tool_policy: \"allowlist\"\n")
			b.WriteString("  allowed_tools:\n")
			for _, rule := range policy.MCPToolRules {
				b.WriteString(fmt.Sprintf("    # Provenance: %s\n", rule.Provenance.String()))
				b.WriteString(fmt.Sprintf("    - server: \"%s\"\n", rule.ServerID))
				b.WriteString(fmt.Sprintf("      tool: \"%s\"\n", rule.ToolName))
				if rule.ContentHash != "" {
					b.WriteString(fmt.Sprintf("      content_hash: \"%s\"\n", rule.ContentHash))
				}
			}
		}

		// Server allowlist
		if len(policy.MCPServers) > 0 {
			b.WriteString("  allowed_servers:\n")
			for _, srv := range policy.MCPServers {
				b.WriteString(fmt.Sprintf("    - id: \"%s\"\n", srv.ServerID))
			}
		}

		// Blocked tools (commented)
		if len(policy.MCPBlockedTools) > 0 {
			b.WriteString("  # --- Blocked tools (uncomment to allow) ---\n")
			b.WriteString("  # denied_tools:\n")
			for _, rule := range policy.MCPBlockedTools {
				if rule.Provenance.Blocked && rule.Provenance.BlockReason != "" {
					b.WriteString(fmt.Sprintf("  #   # BLOCKED: %s\n", rule.Provenance.BlockReason))
				} else {
					b.WriteString("  #   # BLOCKED:\n")
				}
				b.WriteString(fmt.Sprintf("  #   # Provenance: %s\n", rule.Provenance.String()))
				b.WriteString(fmt.Sprintf("  #   - server: \"%s\"\n", rule.ServerID))
				b.WriteString(fmt.Sprintf("  #     tool: \"%s\"\n", rule.ToolName))
			}
		}

		// Version pinning
		if policy.MCPConfig != nil {
			b.WriteString("  version_pinning:\n")
			if policy.MCPConfig.VersionPinning {
				b.WriteString("    enabled: true\n")
				b.WriteString(fmt.Sprintf("    on_change: \"%s\"\n", policy.MCPConfig.VersionOnChange))
				b.WriteString("    auto_trust_first: true\n")
			} else {
				b.WriteString("    enabled: false\n")
			}

			// Cross-server detection
			if policy.MCPConfig.CrossServer {
				b.WriteString("  cross_server:\n")
				b.WriteString("    enabled: true\n")
				for _, rule := range policy.MCPConfig.CrossServerRules {
					b.WriteString(fmt.Sprintf("    %s:\n", rule))
					b.WriteString("      enabled: true\n")
				}
			}
		}

		b.WriteString("\n")
	}

	return b.String()
}

// writeFileRule writes a file rule to the builder.
func writeFileRule(b *strings.Builder, rule FileRuleGen, commented bool) {
	prefix := "  "
	if commented {
		prefix = "#  "
		if rule.Provenance.Blocked && rule.Provenance.BlockReason != "" {
			b.WriteString(fmt.Sprintf("  # BLOCKED: %s\n", rule.Provenance.BlockReason))
		} else {
			b.WriteString("  # BLOCKED:\n")
		}
	}

	b.WriteString(fmt.Sprintf("%s # Provenance: %s\n", prefix, rule.Provenance.String()))
	b.WriteString(fmt.Sprintf("%s - name: %s\n", prefix, rule.Name))
	if rule.Description != "" {
		b.WriteString(fmt.Sprintf("%s   description: %s\n", prefix, rule.Description))
	}
	b.WriteString(fmt.Sprintf("%s   paths: %s\n", prefix, formatStringList(rule.Paths)))
	if len(rule.Operations) > 0 {
		b.WriteString(fmt.Sprintf("%s   operations: %s\n", prefix, formatStringList(rule.Operations)))
	}
	b.WriteString(fmt.Sprintf("%s   decision: %s\n", prefix, rule.Decision))
}

// writeNetworkRule writes a network rule to the builder.
func writeNetworkRule(b *strings.Builder, rule NetworkRuleGen, commented bool) {
	prefix := "  "
	if commented {
		prefix = "#  "
		if rule.Provenance.Blocked && rule.Provenance.BlockReason != "" {
			b.WriteString(fmt.Sprintf("  # BLOCKED: %s\n", rule.Provenance.BlockReason))
		} else {
			b.WriteString("  # BLOCKED:\n")
		}
	}

	b.WriteString(fmt.Sprintf("%s # Provenance: %s\n", prefix, rule.Provenance.String()))
	b.WriteString(fmt.Sprintf("%s - name: %s\n", prefix, rule.Name))
	if rule.Description != "" {
		b.WriteString(fmt.Sprintf("%s   description: %s\n", prefix, rule.Description))
	}
	if len(rule.Domains) > 0 {
		b.WriteString(fmt.Sprintf("%s   domains: %s\n", prefix, formatStringList(rule.Domains)))
	}
	if len(rule.Ports) > 0 {
		b.WriteString(fmt.Sprintf("%s   ports: %s\n", prefix, formatIntList(rule.Ports)))
	}
	if len(rule.CIDRs) > 0 {
		b.WriteString(fmt.Sprintf("%s   cidrs: %s\n", prefix, formatStringList(rule.CIDRs)))
	}
	b.WriteString(fmt.Sprintf("%s   decision: %s\n", prefix, rule.Decision))
}

// writeCommandRule writes a command rule to the builder.
func writeCommandRule(b *strings.Builder, rule CommandRuleGen, commented bool) {
	prefix := "  "
	if commented {
		prefix = "#  "
		if rule.Provenance.Blocked && rule.Provenance.BlockReason != "" {
			b.WriteString(fmt.Sprintf("  # BLOCKED: %s\n", rule.Provenance.BlockReason))
		} else {
			b.WriteString("  # BLOCKED:\n")
		}
	}

	// Add risky indicator
	if rule.Risky {
		if rule.RiskyReason != "" {
			b.WriteString(fmt.Sprintf("%s # RISKY: %s\n", prefix, rule.RiskyReason))
		} else {
			b.WriteString(fmt.Sprintf("%s # RISKY: requires careful review\n", prefix))
		}
	}

	b.WriteString(fmt.Sprintf("%s # Provenance: %s\n", prefix, rule.Provenance.String()))
	b.WriteString(fmt.Sprintf("%s - name: %s\n", prefix, rule.Name))
	if rule.Description != "" {
		b.WriteString(fmt.Sprintf("%s   description: %s\n", prefix, rule.Description))
	}
	b.WriteString(fmt.Sprintf("%s   commands: %s\n", prefix, formatStringList(rule.Commands)))
	if rule.ArgsPattern != "" {
		b.WriteString(fmt.Sprintf("%s   args_pattern: \"%s\"\n", prefix, rule.ArgsPattern))
	}
	b.WriteString(fmt.Sprintf("%s   decision: %s\n", prefix, rule.Decision))
}

// writeUnixRule writes a unix socket rule to the builder.
func writeUnixRule(b *strings.Builder, rule UnixRuleGen) {
	prefix := "  "

	b.WriteString(fmt.Sprintf("%s # Provenance: %s\n", prefix, rule.Provenance.String()))
	b.WriteString(fmt.Sprintf("%s - name: %s\n", prefix, rule.Name))
	if rule.Description != "" {
		b.WriteString(fmt.Sprintf("%s   description: %s\n", prefix, rule.Description))
	}
	b.WriteString(fmt.Sprintf("%s   paths: %s\n", prefix, formatStringList(rule.Paths)))
	if len(rule.Operations) > 0 {
		b.WriteString(fmt.Sprintf("%s   operations: %s\n", prefix, formatStringList(rule.Operations)))
	}
	b.WriteString(fmt.Sprintf("%s   decision: %s\n", prefix, rule.Decision))
}

// formatStringList formats a string slice as a YAML inline list.
func formatStringList(items []string) string {
	if len(items) == 0 {
		return "[]"
	}
	quoted := make([]string, len(items))
	for i, item := range items {
		quoted[i] = fmt.Sprintf("\"%s\"", item)
	}
	return "[" + strings.Join(quoted, ", ") + "]"
}

// formatIntList formats an int slice as a YAML inline list.
func formatIntList(items []int) string {
	if len(items) == 0 {
		return "[]"
	}
	strs := make([]string, len(items))
	for i, item := range items {
		strs[i] = fmt.Sprintf("%d", item)
	}
	return "[" + strings.Join(strs, ", ") + "]"
}

// formatDuration formats a duration in a human-readable way.
func formatDuration(d time.Duration) string {
	if d == 0 {
		return "0s"
	}

	h := d / time.Hour
	d -= h * time.Hour
	m := d / time.Minute
	d -= m * time.Minute
	s := d / time.Second

	var result string
	if h > 0 {
		result = fmt.Sprintf("%dh%dm%ds", h, m, s)
	} else if m > 0 {
		result = fmt.Sprintf("%dm%ds", m, s)
	} else {
		result = fmt.Sprintf("%ds", s)
	}
	return result
}

// truncateID truncates a session ID to 8 characters.
func truncateID(id string) string {
	if len(id) <= 8 {
		return id
	}
	return id[:8]
}
