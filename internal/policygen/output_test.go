// internal/policygen/output_test.go
package policygen

import (
	"strings"
	"testing"
	"time"
)

func TestFormatYAML_Header(t *testing.T) {
	policy := &GeneratedPolicy{
		SessionID:   "abc123",
		GeneratedAt: time.Date(2025, 1, 15, 14, 32, 0, 0, time.UTC),
		Duration:    12*time.Minute + 34*time.Second,
		EventCount:  1847,
	}

	yaml := FormatYAML(policy, "test-policy")

	if !strings.Contains(yaml, "# Generated by: agentsh policy generate abc123") {
		t.Error("missing generated-by header")
	}
	if !strings.Contains(yaml, "# Source session: abc123") {
		t.Error("missing source session")
	}
	if !strings.Contains(yaml, "version: 1") {
		t.Error("missing version")
	}
	if !strings.Contains(yaml, "name: test-policy") {
		t.Error("missing policy name")
	}
}

func TestFormatYAML_FileRules(t *testing.T) {
	policy := &GeneratedPolicy{
		SessionID:   "abc123",
		GeneratedAt: time.Now(),
		FileRules: []FileRuleGen{
			{
				GeneratedRule: GeneratedRule{
					Name:        "workspace-src",
					Description: "Source files",
					Provenance:  Provenance{EventCount: 47},
				},
				Paths:      []string{"/workspace/src/**"},
				Operations: []string{"read", "write"},
				Decision:   "allow",
			},
		},
	}

	yaml := FormatYAML(policy, "test")

	if !strings.Contains(yaml, "file_rules:") {
		t.Error("missing file_rules section")
	}
	if !strings.Contains(yaml, "# Provenance: 47 events") {
		t.Error("missing provenance comment")
	}
	if !strings.Contains(yaml, `paths: ["/workspace/src/**"]`) {
		t.Error("missing paths")
	}
}

func TestFormatYAML_BlockedComments(t *testing.T) {
	policy := &GeneratedPolicy{
		SessionID:   "abc123",
		GeneratedAt: time.Now(),
		BlockedFiles: []FileRuleGen{
			{
				GeneratedRule: GeneratedRule{
					Name: "etc-hosts",
					Provenance: Provenance{
						Blocked:     true,
						BlockReason: "system file denied",
					},
				},
				Paths:    []string{"/etc/hosts"},
				Decision: "allow",
			},
		},
	}

	yaml := FormatYAML(policy, "test")

	if !strings.Contains(yaml, "# --- Blocked operations") {
		t.Error("missing blocked section header")
	}
	if !strings.Contains(yaml, "# BLOCKED:") {
		t.Error("missing BLOCKED marker")
	}
	// Blocked rules should be commented out
	if !strings.Contains(yaml, "#   - name:") {
		t.Error("blocked rules should be commented")
	}
}

func TestFormatYAML_NetworkRules(t *testing.T) {
	policy := &GeneratedPolicy{
		SessionID:   "abc123",
		GeneratedAt: time.Now(),
		NetworkRules: []NetworkRuleGen{
			{
				GeneratedRule: GeneratedRule{
					Name:        "api-access",
					Description: "API endpoints",
					Provenance:  Provenance{EventCount: 12},
				},
				Domains:  []string{"api.example.com"},
				Ports:    []int{443},
				Decision: "allow",
			},
		},
	}

	yaml := FormatYAML(policy, "test")

	if !strings.Contains(yaml, "network_rules:") {
		t.Error("missing network_rules section")
	}
	if !strings.Contains(yaml, `domains: ["api.example.com"]`) {
		t.Error("missing domains")
	}
	if !strings.Contains(yaml, "ports: [443]") {
		t.Error("missing ports")
	}
}

func TestFormatYAML_CommandRules(t *testing.T) {
	policy := &GeneratedPolicy{
		SessionID:   "abc123",
		GeneratedAt: time.Now(),
		CommandRules: []CommandRuleGen{
			{
				GeneratedRule: GeneratedRule{
					Name:        "git-commands",
					Description: "Git operations",
					Provenance:  Provenance{EventCount: 25},
				},
				Commands: []string{"git"},
				Decision: "allow",
				Risky:    false,
			},
			{
				GeneratedRule: GeneratedRule{
					Name:        "curl-downloads",
					Description: "Network downloads",
					Provenance:  Provenance{EventCount: 5},
				},
				Commands:    []string{"curl"},
				ArgsPattern: "^https://.*$",
				Decision:    "allow",
				Risky:       true,
				RiskyReason: "network command",
			},
		},
	}

	yaml := FormatYAML(policy, "test")

	if !strings.Contains(yaml, "command_rules:") {
		t.Error("missing command_rules section")
	}
	if !strings.Contains(yaml, `commands: ["git"]`) {
		t.Error("missing git command")
	}
	// Risky commands should have indicator
	if !strings.Contains(yaml, "# RISKY:") {
		t.Error("missing risky indicator")
	}
	if !strings.Contains(yaml, `args_pattern: "^https://.*$"`) {
		t.Error("missing args_pattern for risky command")
	}
}

func TestFormatYAML_UnixRules(t *testing.T) {
	policy := &GeneratedPolicy{
		SessionID:   "abc123",
		GeneratedAt: time.Now(),
		UnixRules: []UnixRuleGen{
			{
				GeneratedRule: GeneratedRule{
					Name:        "docker-socket",
					Description: "Docker daemon",
					Provenance:  Provenance{EventCount: 8},
				},
				Paths:      []string{"/var/run/docker.sock"},
				Operations: []string{"connect"},
				Decision:   "allow",
			},
		},
	}

	yaml := FormatYAML(policy, "test")

	if !strings.Contains(yaml, "unix_socket_rules:") {
		t.Error("missing unix_socket_rules section")
	}
	if !strings.Contains(yaml, `paths: ["/var/run/docker.sock"]`) {
		t.Error("missing socket path")
	}
}

func TestFormatYAML_EmptyPolicy(t *testing.T) {
	policy := &GeneratedPolicy{
		SessionID:   "empty123",
		GeneratedAt: time.Now(),
	}

	yaml := FormatYAML(policy, "empty")

	// Should still have header and metadata
	if !strings.Contains(yaml, "version: 1") {
		t.Error("missing version")
	}
	if !strings.Contains(yaml, "name: empty") {
		t.Error("missing name")
	}
	// Should not have rule sections if empty
	if strings.Contains(yaml, "file_rules:") {
		t.Error("should not have file_rules section when empty")
	}
}

func TestFormatYAML_DefaultName(t *testing.T) {
	policy := &GeneratedPolicy{
		SessionID:   "abc123def456",
		GeneratedAt: time.Now(),
	}

	yaml := FormatYAML(policy, "")

	if !strings.Contains(yaml, "name: generated-abc123de") {
		t.Error("missing default name with truncated ID")
	}
}

func TestFormatDuration(t *testing.T) {
	tests := []struct {
		duration time.Duration
		expected string
	}{
		{0, "0s"},
		{30 * time.Second, "30s"},
		{5 * time.Minute, "5m0s"},
		{12*time.Minute + 34*time.Second, "12m34s"},
		{1*time.Hour + 23*time.Minute + 45*time.Second, "1h23m45s"},
	}

	for _, tt := range tests {
		t.Run(tt.expected, func(t *testing.T) {
			result := formatDuration(tt.duration)
			if result != tt.expected {
				t.Errorf("formatDuration(%v) = %q, want %q", tt.duration, result, tt.expected)
			}
		})
	}
}

func TestTruncateID(t *testing.T) {
	tests := []struct {
		id       string
		expected string
	}{
		{"abc", "abc"},
		{"abc12345", "abc12345"},
		{"abc123456789", "abc12345"},
	}

	for _, tt := range tests {
		t.Run(tt.id, func(t *testing.T) {
			result := truncateID(tt.id)
			if result != tt.expected {
				t.Errorf("truncateID(%q) = %q, want %q", tt.id, result, tt.expected)
			}
		})
	}
}

func TestFormatStringList(t *testing.T) {
	tests := []struct {
		items    []string
		expected string
	}{
		{nil, "[]"},
		{[]string{}, "[]"},
		{[]string{"a"}, `["a"]`},
		{[]string{"a", "b"}, `["a", "b"]`},
		{[]string{"/path/with spaces"}, `["/path/with spaces"]`},
	}

	for _, tt := range tests {
		t.Run(tt.expected, func(t *testing.T) {
			result := formatStringList(tt.items)
			if result != tt.expected {
				t.Errorf("formatStringList(%v) = %q, want %q", tt.items, result, tt.expected)
			}
		})
	}
}

func TestFormatIntList(t *testing.T) {
	tests := []struct {
		items    []int
		expected string
	}{
		{nil, "[]"},
		{[]int{}, "[]"},
		{[]int{80}, "[80]"},
		{[]int{80, 443}, "[80, 443]"},
	}

	for _, tt := range tests {
		t.Run(tt.expected, func(t *testing.T) {
			result := formatIntList(tt.items)
			if result != tt.expected {
				t.Errorf("formatIntList(%v) = %q, want %q", tt.items, result, tt.expected)
			}
		})
	}
}

func TestFormatYAML_MCPRules(t *testing.T) {
	policy := &GeneratedPolicy{
		SessionID:   "abc123",
		GeneratedAt: time.Now(),
		MCPToolRules: []MCPToolRuleGen{
			{
				GeneratedRule: GeneratedRule{
					Name:       "weather-get_weather",
					Provenance: Provenance{EventCount: 5},
				},
				ServerID:    "weather",
				ToolName:    "get_weather",
				ContentHash: "sha256:abc123",
			},
		},
		MCPServers: []MCPServerRuleGen{
			{ServerID: "weather", ToolCount: 2},
		},
		MCPConfig: &MCPPolicyConfig{
			VersionPinning:  true,
			VersionOnChange: "block",
		},
	}

	yaml := FormatYAML(policy, "test")

	checks := []string{
		"mcp_rules:",
		"enforce_policy: true",
		`tool_policy: "allowlist"`,
		"allowed_tools:",
		`server: "weather"`,
		`tool: "get_weather"`,
		`content_hash: "sha256:abc123"`,
		"allowed_servers:",
		`id: "weather"`,
		"version_pinning:",
		"enabled: true",
		`on_change: "block"`,
	}
	for _, want := range checks {
		if !strings.Contains(yaml, want) {
			t.Errorf("YAML missing %q", want)
		}
	}
}

func TestFormatYAML_MCPBlockedTools(t *testing.T) {
	policy := &GeneratedPolicy{
		SessionID:   "abc123",
		GeneratedAt: time.Now(),
		MCPBlockedTools: []MCPToolRuleGen{
			{
				GeneratedRule: GeneratedRule{
					Name:       "weather-execute_cmd",
					Provenance: Provenance{EventCount: 1, Blocked: true, BlockReason: "version_pin"},
				},
				ServerID:    "weather",
				ToolName:    "execute_cmd",
				Blocked:     true,
				BlockReason: "version_pin",
			},
		},
		MCPConfig: &MCPPolicyConfig{},
	}

	yaml := FormatYAML(policy, "test")

	if !strings.Contains(yaml, "# --- Blocked tools") {
		t.Error("missing blocked tools section header")
	}
	if !strings.Contains(yaml, "# BLOCKED:") {
		t.Error("missing BLOCKED marker")
	}
}

func TestFormatYAML_MCPCrossServer(t *testing.T) {
	policy := &GeneratedPolicy{
		SessionID:   "abc123",
		GeneratedAt: time.Now(),
		MCPConfig: &MCPPolicyConfig{
			CrossServer:      true,
			CrossServerRules: []string{"read_then_send", "burst"},
		},
	}

	yaml := FormatYAML(policy, "test")

	checks := []string{
		"cross_server:",
		"enabled: true",
		"read_then_send:",
		"burst:",
	}
	for _, want := range checks {
		if !strings.Contains(yaml, want) {
			t.Errorf("YAML missing %q", want)
		}
	}
}

func TestFormatYAML_NoMCPSection(t *testing.T) {
	policy := &GeneratedPolicy{
		SessionID:   "abc123",
		GeneratedAt: time.Now(),
		// No MCP data
	}

	yaml := FormatYAML(policy, "test")

	if strings.Contains(yaml, "mcp_rules:") {
		t.Error("should not have mcp_rules section when no MCP activity")
	}
}
